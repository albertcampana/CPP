
Exercise 26.
Basic exercise
Purpose of this exercise: learn to define classes having Vtables whose objects can safely be destroyed.

Consider the classes Base and Derived from the previous exercise. Provide Derived with a default constructor initializing its string to hello from Derived (no need to implement, but it must be declared in the class interface)

Change the class(es) in such a way that a function Base **derivedFactory(size_t size) returns a pointer to size pointers to Derived objects.

In main call derivedFactory followed by the returning the allocated information to the common pool:


    int main()
    {
        Base **bp = derivedFactory(10);

        // add your code here to return all allocated memory to the 
        // common pool.
    }
        

Submit derivedFactory's implementation, the changes to Base and Derived, and main's complete implementation.



Exercise 27.
Basic exercise
Purpose of this exercise: learn to use escalation.

In the exercises about overloading we encountered the enum class Msg. This enum is used in a class Handler, where it is only available to the members of Handler. It is also used in a class Processor, where it is also only available to the members of the that class.

The classes Handler and Processor can be very simple. Submit the class interfaces of these classes as well as any other code you wrote to construct the classes' interfaces.



Exercise 28.
Basic exercise
Purpose of this exercise: Learn to construct your own streambuf class.

Construct and implement the class RandBuffer. The class offers a constructor, expecting resp. int min, int max, and size_t seed min is the smallest random value, max is the largest random value, seed is the value that is used to seed the random number generator, and min must be smaller than max.

As RandBuffer is used for extraction only only one member function must be defined: underflow.

Hints:

    Use the string::copy() member to copy the contents of a string containing the next random value to RandBuffer's buffer. Make sure this buffer is not larger than necessary.
    Use random(3) (and srandom(3)) to generate random numbers.
    To transform a generated random value to a value in the range [min .. max] one of the following procedures could be used (using d_range to represent max - min + 1)
        random() / (RAND_MAX + 0.1) computes doubles in the range [0..0.999...]. Multiplied by range this becomes [0..0.999...] * range, resulting after casting to a size_t in the integral value-range [0..range). E.g.,


        d_range * random() / (RAND_MAX + 0.1)
                    

        Compute d_end: the multiple of d_range closest to RAND_MAX. By ignoring random values >= d_end, each value in the range [0..d_range) has an equal likelihood of occurring. Return such a value % d_end as the next random value. 

For your information and to get you on the road: our implementation of RandBuffer's constructor is:

#include "randbuffer.ih"

RandBuffer::RandBuffer(int min, int max, size_t seed)
:
    d_min(min),
    d_range(max - min + 1),
    d_end(RAND_MAX - RAND_MAX % d_range), // d_end is multiple of d_range
    d_buffer(0)
{
    if (max <= min)
        throw range_error{" min. value must be smaller than max. value"};

    srandom(seed);
    setg(0, 0, 0);              // initially no buffer
}



Exercise 29.
Basic exercise
Purpose of this exercise: learn what happens when using multiple inheritance

Consider the following setup:

    A class Basic defines a default constructor and a constructor expecting an int. Both constructors are provided with a cout stmnt. informing you that it is called.
    A class Deriv1 publicly inherits from Basic. The class interface's body is completely empty (i.e., it is {}).
    A class Deriv2 publicly inherits from Basic. That class interface's body also is completely empty.
    A class Multi publicly inherits from Deriv1 and Deriv2. Other than that, its interface merely declares a default constructor, whose implementation is completely empty. 

A main function has only one line of code, defining a Multi multi object:


    int main()
    {
        Multi multi;
    }
        

    Draw Multi's class hierarchy

    Add the following statement to Multi's constructor:


    cout << static_cast<Basic *>(this) << '\n';
            

    Explain the compiler's error message.

    Change the statement so that there is no compilation error (there are two almost identical ways of doing so. Show both ways and explain the difference between both)

    Keep the statement as-is, and show the required modifications to allow the compiler to compile the statement without errors.

    After solving the previous item, how do you realize that the 2nd Basic constructor (i.e., the one expecting an int) is the only Basic constructor that's called?

    Also, after having prevented compilation errors: also make sure that Deriv1's constructor calls Base's constructor expecting an int. What do you have to change to ensure that only Base's default constructor is called when constructing a Multi object? 



Exercise 30.
Advanced exercise
Purpose: learn to construct an ostream class.

Construct a class BiStream offering the same facilities as ostream, but inserting its information into two files, whose ostream-objects are passed to this class's constructor. So, the following should be possible:


    int main()
    {
        ofstream one("one");
        ofstream two("two");

        BiStream ms(one, two);

        ms << "Hello world" << endl;
    }
        

This inserts the text hello world in both one and two.

Hint: derive a class from streambuf as well. Call it BiStreamBuffer, and also implement this latter class.

Hints: both classes are extremely simple: their members have bodies consisting of at most a few simple expression statements. If you're encountering complexities, then you're doing something wrong, which will be reflected in a lowered rating. Also: keep it simple and don't descend too quickly into the stream's intestines.



Exercise 31.
Advanced exercise
Purpose of this exercise: learn to implement a base class to be used when applying the Template Method Design Pattern.

The fork(2) function allows you to start a copy of the current process (see also the next exercise for an application).

To summarize fork(2): at the fork call a duplicate (a child) of the current program (the parent) is created, and both programs (parent and child) continue beyond the fork() system call. Each program (also called a process) has a process id, and the child's process id is fork's return value in the parent process, while fork's return value equals 0 in the child's process. In theory fork may fail, in which case it returns -1.

Since the above details are invariant over all programs using fork, they are perfectly suited for encapsulation in an abstract base class, only requiring the construction of a derived class in which the parent's actions after calling fork() and in which the child's actions after calling fork() must be implemented.

Design and submit the abstract base class Fork. Fork does not offer copy and move construction or assignment, and has one public member void fork(). In addition it offers the virtual member void parentProcess() (by default not doing anything) and the pure virtual member void childProcess() implementing, respectively, the actions performed by the parent process and the actions actions performed by the child process following the fork. When childProcess() ends the child process must stop. In addition to the public members some protected members must be defined:

    pid_t pid() const returns the child's process id in the parent's code and 0 in the child's code;
    int waitForChild() const This member may be called by parentProcess to wait for the child-process to complete. The return value (exit-code) of the child process is returned as a value between 0 and 255. If the child process terminates before the completion of the parent process, then waitForChild should (must) be called to prevent zombies from appearing. Alternatively, the parent process may terminate while the child process is still alive. This is the normal way to create a daemon process. The implementation of waitForChild is not difficult. Since it's not the core topic of this exercise its implementation is provided here:


        int Fork::waitForChild() const
        {
            int status;
        
            waitpid(d_pid, &status, 0);
        
            return WEXITSTATUS(status);
        }
                



Exercise 32.
Advanced exercise
Purpose of this exercise: learn to use a Base class as a wrapper

Consider the following main and support functions (1 source file used for brevity):

    #include "main.ih"

    void copy(Base const &existing)
    {
        Base bp{ existing };
        bp.hello(1);
    }

    void copy(Base &&tmp)
    {
        Base moved{ move(tmp) };    
        moved.hello(2);
    }

    void assign(Base &lhs, Base const &rhs)
    {
        lhs = rhs;
        lhs.hello(3);
    }

    void assign(Base &lhs, Base &&rhs)
    {
        lhs = move(rhs);
        lhs.hello(4);
    }

    int main()
    {
        Derived derived;

        copy(derived);
        copy(Derived{});

        Derived other;

        assign(other, derived);
        assign(other, Derived{});
    }

Derived objects, derived from a base class Base are constructed in main, and are then passed as arguments to copy and assign functions, where they are copied/assigned using copy and move constructors and assignments that are defined in the class Base. The output of this program is:


    hello 1 fm Derived
    hello 2 fm Derived
    hello 3 fm Derived
    hello 4 fm Derived
        

showing that the various base.hello() calls in fact call the derived class's hello function. A clear case of polymorphic behavior, and in fact only the Base class provides a member hello, which delegates its work to a virtual function vHello, which is called from the derived class since the Base references are in fact referring to Derived class objects.

Design and implement the Base and Derived classes. Both must provide default, copy and move constructors, and copy and move assignment operators, with Base also offering a void hello(int nr) member, delegating, as mentioned, its work to a virtual void vHello member.

In our implementation Base has one additional constructor: Base(Base *bp, bool d_allocated = false), where bp will receive the address of some derived class object, which may or may not have been dynamically allocated: when a derived class object is constructed there's no dynamic allocation, but when it's copied from an existing derived class object then it is, using the `virtual constructor design pattern' which was covered during the lecture on polymorphism.

Hints:

    since the address received by Base(Base *bp, ...) constructor points to a derived class object, polymorphic behavior is only present when called via that pointer.
    since Base has copy and move constructors Base objects must be constructable. That implies that Base cannot be an abstract base class. But its virtual members should never be called, because Base is only used to refer to derived class objects, calling their overridden virtual members. To avoid accidentally calling Base's own virtual members they throw an exception when called. E.g., here's Base's virtual vHello member function:

        //#define XERR
        #include "base.ih"

        // virtual
        void Base::vHello(int nr) const
        {
            throw 1;                    // no plain Base objects allowed
        }

    don't immediately start implementing: first design Base's interface, and make sure you have a clear picture of what Base's members should do. Then design Derived. Having designed Derived implement it, and only then concentrate on the implementation of Base. 

When submitting your answer, first submit the Derived class's header, then the implementations of its members, then the Base class's header, and finally submit Base's member implementations.



    Table of Contents
    Previous Chapter 

