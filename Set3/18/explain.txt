First, when calling each derived constructor, since there is no member initialization, the default base constructor is always called.

Then, we add the matching base constructor call to each derived constructor. As seen in the out2.txt file, now the correct order of constructors is being called.

To answer the last question; The type of calling std::move with a T const argument is a T const&&, which cannot bind to a T&& parameter. But it can bind to a copy parameter.
So we have two options:
1- We could add a new move constructor to recieve as parameter a Base const &&tmp, and inside the the Derived copy constructor member initialization should be "Base(move(other))".
2- We have to remove the const from the Derived copy constructor, which should look something like this "Derived(Derived &other)". And then keep the same member initialization as in answer 1.
